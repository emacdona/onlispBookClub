---
layout: post
published: false
---

# F#: There was always an Option

I've been messing around with F# lately. I've glanced at ML/OCaml/F# code before, but this is my first experience really working in an ML descendant. So far, I'm really liking what I see. Today I encountered something that I found interesting enough to write a few paragraphs about.

## Options

If you're not familiar with what an ___Option___ type is, take a look at the [Wikipedia page](https://en.wikipedia.org/wiki/Option_type). I'll attempt to describe it very briefly as:

_Option: A type that wraps a value of another type, where that value may or may not be present._

Proponents would say that ___Options___ are a better alternative to ___null___ when you desire to express a value which may not exist, because they force you to deal with that fact at compile time.

There is a LOT more to say about Options, but this isn't a blog post about why they exist. This is a blog post about an interesting design choice that appears in a language where library creators have always been able to assume they are present.

## Filtering, Transforming, and Choosing with Options

The ___Option___ type isn't unique to F#. Java, for example, has ___Optional___. However, whereas Java's ___Optional___ is a feature that was added to a language that had already been around for a long time (it was added in Java 1.8), F#'s ___option___ type has been in the language since its inception. In fact, my second edition of _ML for the Working Programmer_, published in 1996, lists an ___option___ type as part of ML's standard library. In other words, F#'s ancestor had options since at least 1996 (and probably long before).

This means that all F# code in existence was written for a platform where ___option___ existed from day one. This has led to library functions that would never have occurred to someone who's been writing Java for over two decades (me).

### Java Example

All programming languages that I've used have had some sort of ___collection___ abstraction, and they've all had _at least_ the two following operations defined for collections: ___filter___ and ___transform___. Sure, these operations often go by different names (___grep___, ___remove-if-not___, ___map___, ...) -- but they are always there.

The ___filter___ function takes two arguments: a collection and a unary predicate. It returns a new collection containing only the elements of the original collection for which the predicate returns ___true___.

The ___transform___ function takes two arguments: a collection and a unary function. It returns a new collection whose elements are the result of applying the function to each element in the original collection.

For example: let's say that given a collection of integers, you wish to take only the even ones and divide them by three, resulting in a collection of floating point numbers. In Java, that could be accomplished as follows:

```shell
$> jshell

jshell> var ints = IntStream.rangeClosed(1,10).mapToObj(Integer::valueOf).collect(Collectors.toList())
ints ==> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

jshell> ints.get(0).getClass()
$27 ==> class java.lang.Integer

jshell> var floats = ints.stream().filter(n -> n % 2 == 0).map(i->i/3.0).collect(Collectors.toList())
floats ==> [0.6666666666666666, 1.3333333333333333, 2.0, 2.6 ... 66665, 3.3333333333333335]

jshell> floats.get(0).getClass()
$29 ==> class java.lang.Double
```

Most of that code is boilerplate that lets me show you the types of the expressions (to convince you that I started with ___ints___ and ended up with ___floats___). The really important part is:

```shell
var floats = ints.stream().filter(n -> n % 2 == 0).map(i->i/3.0).collect(Collectors.toList())
```

Note the successive calls to ___filter___ and ___map___ (a.k.a.: ___transform___). This is the tried and true method of solving this type of problem that I've been using for over two decades.

### F# Example

In F#, the same example uses ___options___ to merge the ___filter___ and ___transform___ operations into the same function! Perhaps to you this may seem like a little thing... but when I saw it, I was taken aback. It's always interesting to see a new way of doing something you've been doing the same way for your entire career:

```shell
$> dotnet fsi

> List.choose;;
val it: (('a -> 'b option) -> 'a list -> 'b list)

> let ints = [1..10];;
val ints: int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]

> ints |> List.choose(fun i -> if i % 2 = 0 then Some(float i / 3.0) e
val it: float list =
  [0.6666666667; 1.333333333; 2.0; 2.666666667; 3.333333333]
```

Look at the signature of ___List.choose___, the method that both "filters" and "transforms":

```
('a -> 'b option) -> 'a list -> 'b list
```

___List.choose___, as its only parameter, takes a function that maps a value of type ___'a___ to an ___option___ of type ___'b___. That function can do two things:
1. Convert an instance of ___'a___ to an instance of ___'b___
2. Indicate inclusion-in or exclusion-from the result via an ___option___

Given this argument, ___List.choose___ then builds a function that can be applied to an input collection (___ints___ in the example) to generate an output collection that has undergone both a "filter" and a "transform"!

Okay, in the spirit of full disclosure: sure, F# also has ___List.filter___ and ___List.map___ (a.k.a.: ___transform___). _Still_, I still find it very interesting that the ___option___ type allowed them to include ___List.choose___ in the standard library. Perhaps it is even _more_ interesting that they opted to do so.
